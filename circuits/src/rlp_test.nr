use crate::rlp::{Eip1559TxRlp, eip1559_signing_hash};

#[test]
fn test_eip1559_signing_hash_simple() {
    let tx = Eip1559TxRlp {
        chain_id: 1,
        nonce: 0,
        max_priority_fee_per_gas: 1,
        max_fee_per_gas: 1,
        gas_limit: 21000,
        to: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        value: 0,
    };
    
    let hash = eip1559_signing_hash(tx);
    
    let expected: [u8; 32] = [
        0xda, 0xca, 0x52, 0xcf, 0xea, 0x52, 0x35, 0xbd,
        0x34, 0x45, 0xa8, 0x8c, 0x83, 0x71, 0xe6, 0x6d,
        0x7e, 0x26, 0xd5, 0x59, 0x73, 0x0f, 0xdb, 0x30,
        0xa7, 0xc1, 0x92, 0xf5, 0x7e, 0x47, 0x30, 0x48
    ];
    
    for i in 0..32 {
        assert(hash[i] == expected[i], "Hash mismatch at byte");
    }
}

#[test]
fn test_eip1559_signing_hash_complex() {
    let tx = Eip1559TxRlp {
        chain_id: 1,
        nonce: 42,
        max_priority_fee_per_gas: 2000000000,
        max_fee_per_gas: 100000000000,
        gas_limit: 21000,
        to: [0xde, 0xad, 0xbe, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01],
        value: 1000000000000000000,
    };
    
    let hash = eip1559_signing_hash(tx);
    
    let expected: [u8; 32] = [
        0x25, 0xd7, 0x4c, 0xc0, 0xfa, 0x8c, 0x42, 0x7e,
        0xb0, 0x02, 0x9a, 0xda, 0x9c, 0xe6, 0x9d, 0xfb,
        0x33, 0x56, 0xc2, 0xb8, 0xdb, 0xbc, 0x99, 0x26,
        0x57, 0xc6, 0xa0, 0x2a, 0x3a, 0x02, 0x88, 0x7b
    ];
    
    for i in 0..32 {
        assert(hash[i] == expected[i], "Hash mismatch at byte");
    }
}
