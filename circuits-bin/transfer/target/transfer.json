{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"12083283497241422538","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"cm_out","type":{"kind":"field"},"visibility":"public"},{"name":"cm_change","type":{"kind":"field"},"visibility":"public"},{"name":"nf_note","type":{"kind":"field"},"visibility":"public"},{"name":"nf_tx","type":{"kind":"field"},"visibility":"public"},{"name":"gas_tip","type":{"kind":"field"},"visibility":"public"},{"name":"gas_fee_cap","type":{"kind":"field"},"visibility":"public"},{"name":"token_type","type":{"kind":"field"},"visibility":"public"},{"name":"pool_id","type":{"kind":"field"},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"tx_chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"tx_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"tx_to","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"tx_value","type":{"kind":"field"},"visibility":"private"},{"name":"tx_max_priority_fee","type":{"kind":"field"},"visibility":"private"},{"name":"tx_max_fee","type":{"kind":"field"},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"note_in_rk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"note_in_value","type":{"kind":"field"},"visibility":"private"},{"name":"note_in_token","type":{"kind":"field"},"visibility":"private"},{"name":"note_in_r","type":{"kind":"field"},"visibility":"private"},{"name":"note_out_rk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"note_out_value","type":{"kind":"field"},"visibility":"private"},{"name":"note_out_r","type":{"kind":"field"},"visibility":"private"},{"name":"note_change_rk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"note_change_value","type":{"kind":"field"},"visibility":"private"},{"name":"note_change_r","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_index","type":{"kind":"field"},"visibility":"private"},{"name":"nk","type":{"kind":"field"},"visibility":"private"},{"name":"recipient_pk_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"recipient_pk_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"2960775931950815831":{"error_kind":"string","string":"Tx nullifier mismatch"},"3822879308769694408":{"error_kind":"string","string":"Field failed to decompose into specified 64 limbs"},"4311175614903742608":{"error_kind":"string","string":"Change commitment mismatch"},"4924752953922582949":{"error_kind":"string","string":"Invalid ECDSA signature"},"5156750900469820035":{"error_kind":"string","string":"Token mismatch"},"5943429403978579468":{"error_kind":"string","string":"Gas tip mismatch"},"6094259615572001638":{"error_kind":"string","string":"Output commitment mismatch"},"7154917642416269823":{"error_kind":"string","string":"Sender does not own input note"},"7323901310833099184":{"error_kind":"string","string":"Value not conserved"},"7413821296130189607":{"error_kind":"string","string":"tx.to mismatch"},"10494580507002630618":{"error_kind":"string","string":"Signature S must be in lower half"},"11240862899742736534":{"error_kind":"string","string":"Note nullifier mismatch"},"12456705425999860210":{"error_kind":"string","string":"Field failed to decompose into specified 20 limbs"},"14369885823843944213":{"error_kind":"string","string":"Invalid Merkle proof"},"14532896615962194335":{"error_kind":"string","string":"Gas fee cap mismatch"},"18369272386990903957":{"error_kind":"string","string":"tx.value mismatch"}}},"bytecode":"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","debug_symbols":"vZ3drhvJeUXfRddzwfp+q/wqQWCM7YkhQBgb8kyAwPC75zS5u5fGATsMW85V7xkdfauK7L1INlvS3z/96ac//Prn33/++T/+8rdPv/u3v3/6w9fPX758/vPvv/zljz/+8vkvP3/837//44dP+3/+/pevP/308b8+ffPrH7/rrz9+/ennXz797udfv3z54dN//vjl1/sP/e2vP/58P/7y49ePX7398Omnn//0cfwY+B+fv/y0pX/8wO++Pf+tccuh3x23ZkCO30wYzyeMdZuaMJblGxPsNkwT7GbzrQlZx4TstybMcUxYb00YlvuEYf3WIzn9eCRXvLWG8mMN/XTC2fkwfJ8QY41nE9bJLm7HGsbwdUwY8fIa7Bb7Gj529M4ufOznQ7g/fyTtZBsZ+wkx8vkDMfz5CE87Hkp2Uf80IE6eTqu92mbflPP/MqKPR8Lan4+ok0ei+3hCe9nTEf18xIq9GivnOwPGzfbH8uP8yqcjTs7LmGNfRMxkG2O9/kis20J1zx+Js9OqsGXlU9eZXTytzC+fVqcjXjutNiNePK2sLp5WZwNePK1sXj6tTh+J73FadR4P5vMXYR8XTyu3y6fV6YjXTiuPy6eV58XT6mzAi6eV9+XT6vSR+A6nVfvgwXz6Ihi3i6dVnL2nsblvw/z2dBtxto1Rx/MxZr41wnkw3Z6eFREXT6uzAS+eVlGXT6vT56PmUfNa/nQV8/qDua4+mK8N6OcP5dmJveZxYudbJ/Zrsku/LLu8elaeDrj1PsDqnQEvntZ53ZanD+Vrtjz90BF9fOiYt3c+tmQc51RWvjVhHR+daox3JhS7qOcXBOrsoawZvBn5ZoT/H0b0YsR4b0RdHtHzm3rVOyM+Pr8etvx4XN4aYUfDzL59b/dPI05k12N/QvrbT+Tr5TV43vZHwnO89WD+ZsR7Z4VnMqLWsxF9NmIeNff5zYM55m9HnPiqrPZHs2zdno043cjHb9xXUf50I2c1bTtq2v6WKvr4JPruhMW1opX+bEKfvQr3RP1PPw3Pq+8v5/X3l/P6+8t5/f3lvPpKPq+/EM/r7y9f3MbzN2bz+vuquS6/r1q3i8/GiwOePw5nA158OpdffzrXv/J9Vd7mLokct/X0knRd1czqi5pZ87Jm1rqsmdMRr2lm3MbVi7lnE169mnu7fmq+upOTis3rV9dv3+Hy+u3y9fUXJ3S+NeHVJ3XcvsOTWv9vwhnrjXdGaWt/d5Zuz788Ovvm5jVnjZFXv4A6+8bjRWuN0+9uXtPW+YwXvTWuXjI6nfDqKW7j+ik+rl67On9eXxSXXb/SPuzqpfZXJ5w8Fpbf4Vm9/i3Q+eN5XVzfasff+fo/47bvI8Of3w5y9iWOx40P6c8nnF13sTguIFnZs0/Yp6uIKj7dvrWPWH68CuRbE/K4UJCz3no2vI5n45vH4X+sYV5+NtZ3eDbm5WdjXn425r/y2ajjbUGc3CJ09hXOa89G5PVn42wVrz0bpxNeejbOJlx+NricmGnPd5G3q89GjuvPRt6uPht5u/psnE24/mwkz8bstybgujcnlB2bqHznu4/s451Adsx3Jky7HQ9k3t6acHx5kuv21oePtfbX8Lo938X9XfnT94d+vJ8x9+cfYOo7vIqfr2Mdt4b6Wu/tJY7zwsL7zRnHR0JLe/5KXKefgzz4HHSyjnn1E93ZV0GvvvPv2/V3/n35KlJ/h6tI/R2uIp0+Gi/eZ3N6fiU37ubJe4uu6+dXX73MOfo7XBLr65ffx7x6/f10wqvn19nXOi+fX//SK+h1q3G8Ikx74zWlRu6fLOvbazj/fG6dfTf08Xpw7MPWyYzL5+e8fh1+zO9wFf30651Xbps538mLTVt2vWlnXxK91rSzCS/f3Z3Xm3b6aFxv2rc9We+8ky7v/R1k+XtdjbG/V6mTazinE1hD3p5OsNPveF67Ceh/mfHSXUD/y4y6PuO1+4BOZ7x4I9D5jNfuBLKzr2leuhXodBUv3gv0+ow3z44X7waycTbjtduB7Owm6RfvBzrfy+Ubgqpux2v8x7B3Wp/HH4GrXPPihDfXUMcdkNXj6XtYG2d3FwcWj+nPZ6yL7zPMbpffZ9jZd0UvfnN2PuO19ypmV1/hTye8+gdt7Por/Ks76XzveX3xTz6dfVv06h99snX5OVmXH4vr34ea23d4Vue/9H3bt96x375v+/eP//rxj5+//uaPbn/6uLj1oYkfPo6pY+nYOs6P374d1+OYNx2HjvbB2o6u48e83o6pY+nYOk4d1+NYtwenho6mo+v4MS+2Y+pYD261jlpfaX2t9bXW11pfa32t9bXW11pfa32t9bXWN7W+qfVNrW9qfVPrm1rf1Pqm1je1vqn1La1vaX1L61ta39L6lta3tL6l9S2tbz3W57fH+vw2dDQdXcfH+vyWOj7W57fWcer4WJ+Pm45Dx8f6fLiOj/V9XFjVsXRsHaeOWp9pfab1mdZnWp9pfab1mdZnWp9pfab1udbnWp9rfa71udbnWp9rfa71udbnWl9ofaH1hdYXWl9ofaH1hdYXWp/64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufrj64eqHqx+ufoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfoT6EepHqB+hfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfqT6kepHqh+pfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfpT6UepHqR+lfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfrT60epHqx+tfkz1Y6ofU/2Y6sdUP6b6MdWPqX5M9WOqH1P9mOrHVD+m+jHVj6l+TPVjqh9T/Zjqx1Q/pvox1Y+pfkz1Y6ofU/2Y6sdUP6b6MdWPqX5M9WOqH1P9mOrHVD+m+jHVj6l+TPVjqh9T/Zjqx1Q/pvox1Y+pfkz1Y6ofU/2Y6sdUP6b6MdWPqX5M9WOqH1P9mOrHVD+m+jHVj6l+TPVjqh9T/Zjqx1Q/pvox1Y+pfkz1Y6ofc+vH3I6pY+n4MW9sx7ldxdzC2i63f4StIdul4LlV5BFsD76Hj6nbJdK51eQRtuuA2+CtKI8wt1s7t7AU7l3ZfulelnvYVrsNvNfl/jOxh9xD7aH3MPewHmFtrXmEsQfbg+8h9pB7qD30HuYe9sljnzz2yWOfPPbJY5889sljnzz2yWOfPPbJtk+2fbLtk22fbPtk2yfbPtn2ybZPtn2y75N9n+z7ZN8n+z7Z98m+T/Z9su+TfZ8c++TYJ8c+OfbJsU+OfXLsk2OfHPvk2CfnPjn3yblPzn1y7pNzn5z75Nwn5z4598m1T659cu2Ta59c++TaJ9c+ufbJtU+ufXLvk3uf3Pvk3if3Prn3yb1P7n1y75N7nzz3yVsHt7sS1tbB7S87W1sHHyH2kHuoPfQe5h6WwtbBRxh72CevffLaJ6998tonr33y2icvTR632+1I40h2JD9SHCmPVEfqI80jHYxxMMbBGAdjHIxxMMbBGAdjHIxxMMbBsINhB2Or5nb/30fyI8WR8kh1pD7SPNLa01ZRpXGkg+EHww+GHww/GH4w/GD4wYiDEQdjq+t2p9lH8iPF9q3YPeWR6kjbC8XtEbfXiu014iOuI27N3eO43495j7bd72b36Pdb3+4xiEms7Vvax4SN5nfa1uQ9riNubd7jIBrRiUFMYhGhFbSC1tAaWkNraA2toTW0htbQGtqENqFNaBPahDahTWgT2oQ2oS1oC9qCtqAtaAvagragLWjroI3bjTiIRnRiEJNYxCZOIrQBbUAb0Aa0AW1AG9AGtAFtQDNoBs2g2Z1W9xjEJBaxiZO4jug34iAaEZpDc2gOzaE5NIcW0AJaQAtoAS2gBbSAFtACWkJLaAktoSW0hJbQElpCS2gFraAVtIJW0ApaQStoBa2gNbSG1tAaWkNraA2toTW0hjahTWgT2oQ2oU1oE9qENqFNaAvagragLWgL2oK2oC1oC9o6aHa7EQfRiE4MYhKL2MRJhDagDWgD2oA2oA1oA9qANqANaAbNoBk0XGK4xHCJ4RLDJYZLDJcYLjFcYrjEcInhEsMlhksMlxguMVxiuMRwieESwyWGSwyXGC4xXGK4xHCJ4RLDJYZLDJcYLjFcYrjEcInhEsMlhksMlxguMVxiuMRwieESwyWGSwyXGC4xXGK4xHCJ4RLDJYZLDJcYLjFcYrjEcInhEsMlhksMlxguMVxiuMRwieESwyWGSwyXGC4xXGK4xHCJ4RLDJY5LHJc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFcErgkcEngksAlgUsClwQuCVwSuCRwSeCSwCWBSwKXBC4JXBK4JHBJ4JLAJYFLApcELglcErgkcEngksAlgUsClwQuiYdL+h432vaXF4z77Ul7DGISi9jESVxHvLtEcRChBbSAFtACWkALaAEtoSW0hJbQElpCS2gJLaEltIJW0ApaQStoBa2gFbSCVtAaWkNraA2toTW0htbQGlpDm9AmtAltQpvQJrQJbUKb0Ca0BW1BW9AWtAVtQVvQFrS7S7a/hH/cb7J6xPt9VnscRCM6MYhJLGITJxHagDagDWgD2oA2oA1oA9qANqAZNINm0AyaQTNoBs2gGTSD5tAcmkNzaA7NoTk0h+bQHFpAC2gBLaAFtIAW0AJaQAtoCS2hJbSEltASWkJLaAktoRW0glbQClpBK2gFraAVtILW0BpaQ2toDa2hNbSG1tAa2oQ2oU1oE9qENqFNaBPahDahLWgL2oK2oC1oC9qCtqDhksQlhUsKlxQuKVxSuKRwSeGSwiWFSwqXFC4pXFK4pHBJ4ZLCJYVLCpcULilcUrikcEnhksIlhUsKlxQuKVxSuKRwSeGSwiWFSwqXFC4pXFK4pHBJ4ZLCJYVLCpcULilcUrikcEnhksIlhUsKlxQuKVxSuKRwSeGSwiWFSwqXFC4pXFK4pHBJ4ZLCJYVLCpcULilcUrikcEnhksIlhUsKlxQuKVxSuKRwSeGSwiWFSwqXFC4pXFK4pHBJ4ZLCJYVLCpcULilcUrikcEnhksIlhUsKlxQuKVzSuKRxSeOSxiWNSxqXNC5pXNK4pHFJ45LGJY1LGpc0Lmlc0rikcUnjksYljUsalzQuaVzSuKRxSeOSxiWNSxqXNC5pXNK4pHFJ45LGJY1LGpc0Lmlc0rikcUnjksYljUsalzQuaVzSuKRxSeOSxiWNSxqXNC5pXNK4pHFJ45LGJY1LGpc0Lmlc0rikcUnjksYljUsalzQuaVzSuKRxSeOSxiWNSxqXNC5pXNK4pHFJ45LGJY1LGpc0Lmlc0rikcUnjksYljUsalzQuaVzSuKRxSeOSxiUTl0xcMnHJxCUTl0xcMh8u8Xu80+oeJ3Ed8eGSRxxEIzoxiEksIrQBbUAzaAbNoBk0g2bQDJpBM2gGzaE5NIfm0ByaQ3NoDs2hObSAFtACWkALaAEtoAW0gBbQElpCS2gJLaEltISW0BJaQitoBa2gFbSCVtAKWkEraAWtoTW0hvZwybzHICaxiE2cxHXEh0secRCNCG1Cm9AmtAltQpvQFrQFbUFb0Ba0BW1BW9AWtHXQ1u1GHEQjOjGISSxiEycR2oA2oA1oA9qANqANaAPagDagGTSDZtAMmkEzaAbNoBk0g+bQHJpDc2gOzaE5NIfm0BxaQAtoAS2gBbSAFtACWkALaAktoSW0hJbQElpCS2gJLaEVtIJW0ApaQStoBa2gFbSC1tAaWkPDJQuXLFyycMnCJQuXLFyycMnCJQuXLFyycMnCJQuXLFyycMnCJQuXLFyycMnCJQuXLFyycMnCJQuXrMMldjtcYrfDJXY7XGK3wyV2O1xit8MldjtcYrfDJXY7XGK3G7QBbUAb0Aa0AW1AG9AGtAFtQDNoBs2gGTSDZtAMmkEzaAbNoTk0h+bQHJpDc2gOzaE5tIAW0AJaQAtoAS2gBbSAFtASWkJLaAktoSW0hJbQElpCK2gFraAVtIJW0ApaQStoBa2hNbSG1tAaWkNraA2toTW0CW1Cm9AmtAltQpvQJrQJbUJb0Ba0BW1BW9AWtAVtQVvQcMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJQOXDFwycMnAJY/7Xre/fNce971uf7mdPe57VQxiEovYxElcR7y7RHEQoS1oC9qCtqAtaAvaOmiP+14VB9GITgxiEovYxEmENqANaAPagDagDWgD2oA2oA1oBs2gGTSDZtAMmkEzaAbNoDk0h+bQHJpDc2gOzaE5NIcW0AJaQAtoAS2gBbSAdnfJ9m+M2+O+10e8u0RxEI3oxCAmsYhNhJbQClpBK2gFraAVtIJW0ApaQWtoDa2hNbSG1tAaWkNraA1tQpvQJrQJbUKb0Ca0CW1Cm9AWtAVtQVvQFrQFbUFb0Ba0ddAe970qDqIRnRjEJBaxiZMIbUAb0Aa0AW1AG9AGtAFtQBvQDJpBM2gGzaAZNINm0AyaQXNoDs2hOTSH5tAcmkNzaA4toAW0gBbQAlpAC2gBDZc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFc4rjEcYnjEscljksclzgucVziuMRxieMSxyWOSxyXOC5xXOK4xHGJ4xLHJY5LHJc4LnFc4rgkcEngksAlgUsClwQuCVwSuCRwSeCSwCWBSwKXBC4JXBK4JHBJ4JLAJYFLApcELglcErgkcEngksAlgUsClwQuCVwSuCRwSeCSwCWBSwKXBC4JXBK4JHBJ4JLAJYFLApcELglcErgkcEngksAlgUsClwQuCVwSuCRwSeCSwCWBSwKXBC4JXBK4JHBJ4JLAJYFLApcELglcErgkcEngksAlgUsClwQuCVwSuCRwSeCSwCWBSwKXBC4JXBK4JHBJ4JLAJYFLApcELglcErgkcEngksAlgUsSlyQuSVySuCRxSeKSxCWJSxKXJC5JXJK4JHFJ4pLEJYlLEpckLklckrgkcUniksQliUsSlyQuSVySuCRxSeKSxCWJSxKXJC5JXJK4JHFJ4pLEJYlLEpckLklckrgkcUniksQliUsSlyQuSVySuCRxSeKSxCWJSx73vWbe453W93inzXu807arB4/7Xre/psYe971u/6yQPe57rfuwu0sUg5jEIjZxEtcR7y5RHERoDa2hNbSG1tAaWkOb0Ca0CW1Cu7ukH3Gjbf88iD3ue+37w3d3iX5gEtfxs3eXKI7jB+4uUXR+IIjJDxSx+YFJXPsPPO57VRz7Dzzue1V0fiCIyQ8UsfmBSTz29rjvVfHY2+O+V0XnB4KY/EARmx+YRPZm7M3Ym7E3Y2/G3oy9GXsz9mbszdibszdnb87enL05e3P25uzN2ZuzN2dvwd6CvQV7C/YW7C3YW7C3YG/B3oK9JXtL9pbsLdlbsrdkb8nekr0le0v2Vuyt2Fuxt7tLZt7jRlt1j0ncaGveY29/H9fjZydxHXFzyR4H0YhODGISiwitoTW0CW1Cm9AmtAltQpvQJrQJbUJb0Ba0BW1BW9AWtAVtQVvQ1kG73/e6x0E0ohODmMQiNnESoQ1oA9qANqANaAPagDagDWgDmkEzaAbNoBk0g2bQDJpBM2gOzaE5NIfm0ByaQ3NoDs2hBbSAFtACWkALaAEtoAW0gJbQElpCS2gJLe+0eY8bbfsrlOx+3+seJ3EdcXPJHgfRiE4MYhKhFbSCVtAaWkNraA2toTW0htbQGlpDm9AmtAltQpvQJrQJbUKb0Ca0BW1BW9AWtAVtQbu7xOoem7jR/PEDa4/3+173OIgbzbd/TuY/f/z6+cc/fPnpb59+9/ft32T59ec/7v8Ay8d//vJff91/5Q9fP3/58vnPv//r17/88ac//fr1p+0fa7n/2j/+/R//DQ==","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\nfn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse keccak256::keccak256;\nuse std::ecdsa_secp256k1::verify_signature;\n\nglobal TREE_DEPTH: u32 = 20;\n\nglobal DOMAIN_COMMITMENT: Field = 1;\nglobal DOMAIN_MERKLE_NODE: Field = 2;\nglobal DOMAIN_NULLIFIER: Field = 3;\nglobal DOMAIN_KEY_DERIVATION: Field = 4;\n\nfn assert_u64(value: Field) {\n    let bits = value.to_le_bits::<64>();\n    let mut reconstructed: Field = 0;\n    let mut power: Field = 1;\n    for i in 0..64 {\n        if bits[i] == 1 {\n            reconstructed += power;\n        }\n        power *= 2;\n    }\n    assert(reconstructed == value);\n}\n\nglobal SECP256K1_N_OVER_2: [u8; 32] = [\n    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,\n    0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa0,\n];\n\nstruct Note {\n    rk_hash: Field,\n    value: Field,\n    token_type: Field,\n    r: Field,\n}\n\nfn commit_note(note: Note) -> Field {\n    Poseidon2::hash([DOMAIN_COMMITMENT, note.rk_hash, note.value, note.token_type, note.r], 5)\n}\n\nfn hash_merkle_node(left: Field, right: Field) -> Field {\n    Poseidon2::hash([DOMAIN_MERKLE_NODE, left, right], 3)\n}\n\nfn compute_nullifier(cm: Field, nk: Field) -> Field {\n    Poseidon2::hash([DOMAIN_NULLIFIER, cm, nk], 3)\n}\n\nfn compute_tx_nullifier(nk: Field, chain_id: Field, pool_id: Field, from: Field, nonce: Field) -> Field {\n    Poseidon2::hash([DOMAIN_NULLIFIER, nk, chain_id, pool_id, from, nonce], 6)\n}\n\nfn derive_rk_hash(nk: Field) -> Field {\n    let pnk = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 0], 3);\n    let ek_x = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 1], 3);\n    let ek_y = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 2], 3);\n    Poseidon2::hash([DOMAIN_KEY_DERIVATION, pnk, ek_x, ek_y], 4)\n}\n\nfn is_low_s(signature: [u8; 64]) -> bool {\n    let mut result: i8 = 0;\n    for i in 0..32 {\n        let s_byte = signature[32 + i];\n        let n2_byte = SECP256K1_N_OVER_2[i];\n        if result == 0 {\n            if s_byte < n2_byte {\n                result = 1;\n            } else if s_byte > n2_byte {\n                result = -1;\n            }\n        }\n    }\n    result >= 0\n}\n\nfn compute_merkle_root(leaf: Field, path: [Field; TREE_DEPTH], index: Field) -> Field {\n    let mut current = leaf;\n    let index_bits = index.to_le_bits::<20>();\n    for i in 0..TREE_DEPTH {\n        let sibling = path[i];\n        let is_right = index_bits[i] != 0;\n        if is_right {\n            current = hash_merkle_node(sibling, current);\n        } else {\n            current = hash_merkle_node(current, sibling);\n        }\n    }\n    current\n}\n\n/// Transfer circuit entry point\n/// Public inputs match VoidgunPool.sol shieldedTransfer:\n/// [root, cmOut, cmChange, nfNote, nfTx, gasTip, gasFeeCap, tokenType, poolId]\nfn main(\n    // Public inputs (9 elements)\n    root: pub Field,\n    cm_out: pub Field,\n    cm_change: pub Field,\n    nf_note: pub Field,\n    nf_tx: pub Field,\n    gas_tip: pub Field,\n    gas_fee_cap: pub Field,\n    token_type: pub Field,\n    pool_id: pub Field,\n    \n    // Transaction data (private)\n    tx_hash: [u8; 32],\n    tx_chain_id: Field,\n    tx_nonce: Field,\n    tx_to: [u8; 20],\n    tx_value: Field,\n    tx_max_priority_fee: Field,\n    tx_max_fee: Field,\n    \n    // ECDSA signature (private)\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    \n    // Input note (private)\n    note_in_rk_hash: Field,\n    note_in_value: Field,\n    note_in_token: Field,\n    note_in_r: Field,\n    \n    // Output note (private)\n    note_out_rk_hash: Field,\n    note_out_value: Field,\n    note_out_r: Field,\n    \n    // Change note (private)\n    note_change_rk_hash: Field,\n    note_change_value: Field,\n    note_change_r: Field,\n    \n    // Merkle proof (private)\n    merkle_path: [Field; TREE_DEPTH],\n    merkle_index: Field,\n    \n    // Nullifying key (private)\n    nk: Field,\n    \n    // Recipient public key (private)\n    recipient_pk_x: [u8; 32],\n    recipient_pk_y: [u8; 32],\n) {\n    // 1. Verify ECDSA signature\n    assert(is_low_s(signature), \"Signature S must be in lower half\");\n    let is_valid_sig = verify_signature(pub_key_x, pub_key_y, signature, tx_hash);\n    assert(is_valid_sig, \"Invalid ECDSA signature\");\n    \n    // 2. Verify sender owns input note\n    let sender_rk_hash = derive_rk_hash(nk);\n    assert(sender_rk_hash == note_in_rk_hash, \"Sender does not own input note\");\n    \n    // 3. Verify tx.to matches recipient\n    let mut pk_bytes: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        pk_bytes[i] = recipient_pk_x[i];\n        pk_bytes[i + 32] = recipient_pk_y[i];\n    }\n    let pk_hash: [u8; 32] = keccak256(pk_bytes, 64);\n    for i in 0..20 {\n        assert(pk_hash[i + 12] == tx_to[i], \"tx.to mismatch\");\n    }\n    \n    // 4. Verify note commitments\n    let note_in = Note { rk_hash: note_in_rk_hash, value: note_in_value, token_type: note_in_token, r: note_in_r };\n    let cm_in = commit_note(note_in);\n    \n    let note_out = Note { rk_hash: note_out_rk_hash, value: note_out_value, token_type: token_type, r: note_out_r };\n    assert(commit_note(note_out) == cm_out, \"Output commitment mismatch\");\n    \n    let note_change = Note { rk_hash: note_change_rk_hash, value: note_change_value, token_type: token_type, r: note_change_r };\n    assert(commit_note(note_change) == cm_change, \"Change commitment mismatch\");\n    \n    // 5. Value conservation\n    assert_u64(note_in_value);\n    assert_u64(note_out_value);\n    assert_u64(note_change_value);\n    assert_u64(tx_value);\n    assert(note_in_value == note_out_value + note_change_value, \"Value not conserved\");\n    assert(note_in_token == token_type, \"Token mismatch\");\n    \n    // 6. Bind tx.value to output\n    assert(tx_value == note_out_value, \"tx.value mismatch\");\n    \n    // 7. Verify gas parameters\n    assert(tx_max_priority_fee == gas_tip, \"Gas tip mismatch\");\n    assert(tx_max_fee == gas_fee_cap, \"Gas fee cap mismatch\");\n    \n    // 8. Verify Merkle proof\n    let computed_root = compute_merkle_root(cm_in, merkle_path, merkle_index);\n    assert(computed_root == root, \"Invalid Merkle proof\");\n    \n    // 9. Verify note nullifier\n    assert(compute_nullifier(cm_in, nk) == nf_note, \"Note nullifier mismatch\");\n    \n    // 10. Verify transaction nullifier\n    let mut sender_pk_bytes: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        sender_pk_bytes[i] = pub_key_x[i];\n        sender_pk_bytes[i + 32] = pub_key_y[i];\n    }\n    let sender_hash: [u8; 32] = keccak256(sender_pk_bytes, 64);\n    let mut sender_addr: Field = 0;\n    for i in 0..20 {\n        sender_addr = sender_addr * 256 + sender_hash[i + 12] as Field;\n    }\n    assert(compute_tx_nullifier(nk, tx_chain_id, pool_id, sender_addr, tx_nonce) == nf_tx, \"Tx nullifier mismatch\");\n}\n","path":"/Users/user/pse/voidgun/circuits-bin/transfer/src/main.nr"},"53":{"source":"mod tests;\n\nuse std::hash::keccak::keccakf1600;\nuse std::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // `real_max_blocks` is guaranteed to at least be `1`\n    // We peel out the first block as to avoid a conditional inside of the loop.\n    // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n    for j in 0..LIMBS_PER_BLOCK {\n        state[j] = sliced_buffer[j];\n    }\n    state = keccakf1600(state);\n\n    let state = if is_unconstrained() {\n        // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n        // thus allowing us to simplify the loop body.\n        for i in 1..real_max_blocks {\n            for j in 0..LIMBS_PER_BLOCK {\n                state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n            }\n            state = keccakf1600(state);\n        }\n\n        state\n    } else {\n        // We store the intermediate states in an array to avoid having a dynamic predicate\n        // inside the loop, which can cause a blowup in a constrained runtime.\n        let mut intermediate_states = [state; (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES + 1];\n        for i in 1..max_blocks {\n            let mut previous_state = intermediate_states[i - 1];\n            for j in 0..LIMBS_PER_BLOCK {\n                previous_state[j] = previous_state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n            }\n            intermediate_states[i] = keccakf1600(previous_state);\n        }\n\n        // We can then take the state as of `real_max_blocks`, ignoring later permutations.\n        intermediate_states[real_max_blocks - 1]\n    };\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/Users/user/nargo/github.com/noir-lang/keccak256/v0.1.1/src/keccak256.nr"},"61":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/user/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}