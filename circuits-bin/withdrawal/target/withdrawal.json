{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"7032124311196547863","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nf_note","type":{"kind":"field"},"visibility":"public"},{"name":"nf_tx","type":{"kind":"field"},"visibility":"public"},{"name":"value","type":{"kind":"field"},"visibility":"public"},{"name":"token_type","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"pool_id","type":{"kind":"field"},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"tx_chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"tx_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"note_rk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"note_value","type":{"kind":"field"},"visibility":"private"},{"name":"note_token","type":{"kind":"field"},"visibility":"private"},{"name":"note_r","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_index","type":{"kind":"field"},"visibility":"private"},{"name":"nk","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"2960775931950815831":{"error_kind":"string","string":"Tx nullifier mismatch"},"3822879308769694408":{"error_kind":"string","string":"Field failed to decompose into specified 64 limbs"},"4924752953922582949":{"error_kind":"string","string":"Invalid ECDSA signature"},"5047277998805030746":{"error_kind":"string","string":"Recipient mismatch - must withdraw to own address"},"7154917642416269823":{"error_kind":"string","string":"Sender does not own input note"},"9496310242935454321":{"error_kind":"string","string":"Value mismatch"},"10494580507002630618":{"error_kind":"string","string":"Signature S must be in lower half"},"11240862899742736534":{"error_kind":"string","string":"Note nullifier mismatch"},"12456705425999860210":{"error_kind":"string","string":"Field failed to decompose into specified 20 limbs"},"13953184967523250190":{"error_kind":"string","string":"Token type mismatch"},"14369885823843944213":{"error_kind":"string","string":"Invalid Merkle proof"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\nfn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse keccak256::keccak256;\nuse std::ecdsa_secp256k1::verify_signature;\n\nglobal TREE_DEPTH: u32 = 20;\n\nglobal DOMAIN_COMMITMENT: Field = 1;\nglobal DOMAIN_MERKLE_NODE: Field = 2;\nglobal DOMAIN_NULLIFIER: Field = 3;\nglobal DOMAIN_KEY_DERIVATION: Field = 4;\n\nfn assert_u64(value: Field) {\n    let bits = value.to_le_bits::<64>();\n    let mut reconstructed: Field = 0;\n    let mut power: Field = 1;\n    for i in 0..64 {\n        if bits[i] == 1 {\n            reconstructed += power;\n        }\n        power *= 2;\n    }\n    assert(reconstructed == value);\n}\n\nglobal SECP256K1_N_OVER_2: [u8; 32] = [\n    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x5d, 0x57, 0x6e, 0x73, 0x57, 0xa4, 0x50, 0x1d,\n    0xdf, 0xe9, 0x2f, 0x46, 0x68, 0x1b, 0x20, 0xa0,\n];\n\nstruct Note {\n    rk_hash: Field,\n    value: Field,\n    token_type: Field,\n    r: Field,\n}\n\nfn commit_note(note: Note) -> Field {\n    Poseidon2::hash([DOMAIN_COMMITMENT, note.rk_hash, note.value, note.token_type, note.r], 5)\n}\n\nfn hash_merkle_node(left: Field, right: Field) -> Field {\n    Poseidon2::hash([DOMAIN_MERKLE_NODE, left, right], 3)\n}\n\nfn compute_nullifier(cm: Field, nk: Field) -> Field {\n    Poseidon2::hash([DOMAIN_NULLIFIER, cm, nk], 3)\n}\n\nfn compute_tx_nullifier(nk: Field, chain_id: Field, pool_id: Field, from: Field, nonce: Field) -> Field {\n    Poseidon2::hash([DOMAIN_NULLIFIER, nk, chain_id, pool_id, from, nonce], 6)\n}\n\nfn derive_rk_hash(nk: Field) -> Field {\n    let pnk = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 0], 3);\n    let ek_x = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 1], 3);\n    let ek_y = Poseidon2::hash([DOMAIN_KEY_DERIVATION, nk, 2], 3);\n    Poseidon2::hash([DOMAIN_KEY_DERIVATION, pnk, ek_x, ek_y], 4)\n}\n\nfn is_low_s(signature: [u8; 64]) -> bool {\n    let mut result: i8 = 0;\n    for i in 0..32 {\n        let s_byte = signature[32 + i];\n        let n2_byte = SECP256K1_N_OVER_2[i];\n        if result == 0 {\n            if s_byte < n2_byte {\n                result = 1;\n            } else if s_byte > n2_byte {\n                result = -1;\n            }\n        }\n    }\n    result >= 0\n}\n\nfn compute_merkle_root(leaf: Field, path: [Field; TREE_DEPTH], index: Field) -> Field {\n    let mut current = leaf;\n    let index_bits = index.to_le_bits::<20>();\n    for i in 0..TREE_DEPTH {\n        let sibling = path[i];\n        let is_right = index_bits[i] != 0;\n        if is_right {\n            current = hash_merkle_node(sibling, current);\n        } else {\n            current = hash_merkle_node(current, sibling);\n        }\n    }\n    current\n}\n\n/// Withdrawal circuit entry point\n/// Public inputs match VoidgunPool.sol withdraw:\n/// [root, nfNote, nfTx, value, tokenType, recipient, poolId]\nfn main(\n    // Public inputs (7 elements)\n    root: pub Field,\n    nf_note: pub Field,\n    nf_tx: pub Field,\n    value: pub Field,\n    token_type: pub Field,\n    recipient: pub Field,  // recipient address as Field (uint160)\n    pool_id: pub Field,\n    \n    // Transaction data (private)\n    tx_hash: [u8; 32],\n    tx_chain_id: Field,\n    tx_nonce: Field,\n    \n    // ECDSA signature (private)\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    \n    // Input note (private)\n    note_rk_hash: Field,\n    note_value: Field,\n    note_token: Field,\n    note_r: Field,\n    \n    // Merkle proof (private)\n    merkle_path: [Field; TREE_DEPTH],\n    merkle_index: Field,\n    \n    // Nullifying key (private)\n    nk: Field,\n) {\n    // 1. Verify ECDSA signature\n    assert(is_low_s(signature), \"Signature S must be in lower half\");\n    let is_valid_sig = verify_signature(pub_key_x, pub_key_y, signature, tx_hash);\n    assert(is_valid_sig, \"Invalid ECDSA signature\");\n    \n    // 2. Verify sender owns input note\n    let sender_rk_hash = derive_rk_hash(nk);\n    assert(sender_rk_hash == note_rk_hash, \"Sender does not own input note\");\n    \n    // 3. Verify note commitment and Merkle proof\n    let note = Note { rk_hash: note_rk_hash, value: note_value, token_type: note_token, r: note_r };\n    let cm = commit_note(note);\n    let computed_root = compute_merkle_root(cm, merkle_path, merkle_index);\n    assert(computed_root == root, \"Invalid Merkle proof\");\n    \n    // 4. Verify value matches (with range check)\n    assert_u64(note_value);\n    assert_u64(value);\n    assert(note_value == value, \"Value mismatch\");\n    \n    // 5. Verify token type matches\n    assert(note_token == token_type, \"Token type mismatch\");\n    \n    // 6. Verify recipient matches sender address (derived from signing key)\n    let mut pk_bytes: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        pk_bytes[i] = pub_key_x[i];\n        pk_bytes[i + 32] = pub_key_y[i];\n    }\n    let pk_hash: [u8; 32] = keccak256(pk_bytes, 64);\n    let mut sender_addr: Field = 0;\n    for i in 0..20 {\n        sender_addr = sender_addr * 256 + pk_hash[i + 12] as Field;\n    }\n    assert(sender_addr == recipient, \"Recipient mismatch - must withdraw to own address\");\n    \n    // 7. Verify note nullifier\n    assert(compute_nullifier(cm, nk) == nf_note, \"Note nullifier mismatch\");\n    \n    // 8. Verify transaction nullifier (for replay protection)\n    assert(compute_tx_nullifier(nk, tx_chain_id, pool_id, sender_addr, tx_nonce) == nf_tx, \"Tx nullifier mismatch\");\n}\n","path":"/Users/user/pse/voidgun/circuits-bin/withdrawal/src/main.nr"},"53":{"source":"mod tests;\n\nuse std::hash::keccak::keccakf1600;\nuse std::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // `real_max_blocks` is guaranteed to at least be `1`\n    // We peel out the first block as to avoid a conditional inside of the loop.\n    // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n    for j in 0..LIMBS_PER_BLOCK {\n        state[j] = sliced_buffer[j];\n    }\n    state = keccakf1600(state);\n\n    let state = if is_unconstrained() {\n        // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n        // thus allowing us to simplify the loop body.\n        for i in 1..real_max_blocks {\n            for j in 0..LIMBS_PER_BLOCK {\n                state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n            }\n            state = keccakf1600(state);\n        }\n\n        state\n    } else {\n        // We store the intermediate states in an array to avoid having a dynamic predicate\n        // inside the loop, which can cause a blowup in a constrained runtime.\n        let mut intermediate_states = [state; (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES + 1];\n        for i in 1..max_blocks {\n            let mut previous_state = intermediate_states[i - 1];\n            for j in 0..LIMBS_PER_BLOCK {\n                previous_state[j] = previous_state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n            }\n            intermediate_states[i] = keccakf1600(previous_state);\n        }\n\n        // We can then take the state as of `real_max_blocks`, ignoring later permutations.\n        intermediate_states[real_max_blocks - 1]\n    };\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/Users/user/nargo/github.com/noir-lang/keccak256/v0.1.1/src/keccak256.nr"},"61":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/user/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}